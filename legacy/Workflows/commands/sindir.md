---
description: Analyze external system/project and integrate discovered features into YBIS core and development level through systematic reverse engineering
---

YBIS Sindir (System Digestion) - Advanced meta-system command for analyzing and integrating external systems into YBIS framework.

User input:

$ARGUMENTS

Goal: Perform comprehensive analysis of external systems/projects, extract ALL system components (structural, functional, knowledge, integration), then integrate the complete ecosystem into YBIS Meta/ and development levels following Constitutional principles.

**Universal Inclusion Principle**: Any component contributing to system operation, understanding, or integration is included - not limited to end-user executables but encompassing the entire intellectual and operational asset ecosystem.

Execution steps:

## Phase 0: Related Systems Discovery
1. **Target System Analysis** → Parse primary target system
   - Validate target accessibility and permissions
   - Determine system type and structure

2. **Related Output Detection** → Discover connected systems
   - Scan for platform-specific directories (.claude/, .vscode/, .github/ etc.)
   - Identify export/output relationships
   - Map source → export connections

3. **Cross-Reference Mapping** → Build complete system map
   - Document all related components
   - Identify system boundaries and interfaces
   - Create comprehensive analysis scope

## Phase 1: System Analysis
1. **Target Identification** → Parse target system from arguments
   - Support file paths, URLs, or project directories
   - Validate accessibility and permissions
   - Determine system type (web app, CLI, library, etc.)

2. **Structure Scanning** → Deep analysis of system architecture
   - File/directory structure mapping
   - Configuration file detection (.json, .yaml, .toml, .env)
   - Dependency analysis (package.json, requirements.txt, etc.)
   - Pattern recognition (MVC, microservices, monolith)

2b. **Behavioral Pattern Detection** → Identify dynamic system behaviors
   - Multi-step process flows (command chains, workflows)
   - Agent/component coordination patterns
   - Team/role-based interaction models
   - Orchestration and automation sequences
   - Cross-component communication protocols

3. **Universal Component Analysis** → Comprehensive system component extraction
   - **Structural Components**: Architecture patterns, configs, setup files, directory organization
   - **Functional Components**: Executables, templates, scripts, generators, business logic
   - **Knowledge Components**: Guidelines, procedures, reference data, best practices, documentation
   - **Integration Components**: APIs, interfaces, workflows, team configs, external connections
   - **Behavioral Components**: Multi-step processes, orchestration patterns, coordination mechanisms
   - **All components contributing to system operation, understanding, or integration are included**

## Phase 2: YBIS Mapping & Type Synthesis
4. **Component Classification & Type Mapping** → Systematic categorization
   - **Structural → YBIS Types**: config, setup, architecture patterns
   - **Functional → YBIS Types**: agent, task, template, script, command
   - **Knowledge → YBIS Types**: guide, procedure, data, reference, documentation
   - **Integration → YBIS Types**: api, interface, connector
   - **Behavioral → YBIS Types**: workflow, orchestrator, team, coordination
   - **Relationship Analysis**: Inter-component dependencies, execution flows, coordination patterns
   - Check against current registry types and identify YBIS type gaps

5. **Type Synthesis Planning** → Create new types if needed
   - Generate schema/template/contract for missing types
   - Follow Constitutional type creation principles
   - Ensure Meta-First and Platform-Agnostic compliance

## Phase 3: Missing Data Types Creation
6. **Data Type Gap Analysis** → Identify missing YBIS types
   - Compare discovered components with existing YBIS types
   - List required new types (script, template, command, workflow, orchestrator, team, etc.)
   - **Critical Focus**: Don't miss behavioral patterns - workflows, orchestration, team coordination
   - Plan type synthesis order and dependencies considering behavioral relationships

7. **Type Synthesis Execution** → Create missing types
   - Generate complete type definitions (schema, template, contract)
   - Follow YBIS Constitutional type creation standards
   - Update Meta registry with new types

## Phase 4: Functional Script Data Generation
8. **Script Analysis & Mapping** → Analyze discovered scripts
   - Parse script functionality and parameters
   - Map script operations to YBIS workflows
   - Identify script dependencies and interfaces

9. **YBIS Script Data Generation** → Create functional equivalents
   - Generate YBIS-native script data that replicates functionality
   - Create parameter mappings and execution workflows
   - Ensure Constitutional compliance and validation

## Phase 5: Meta-Level Integration
10. **Meta Registry Update** → Integrate into YBIS core system
    - Add new type definitions to Meta/
    - Update Engine routing if needed
    - Create validation rules
    - Update Constitution if required

11. **Engine Enhancement** → Extend YBIS capabilities
    - Add new engine modules if system introduces novel workflows
    - Update export adapters for new types
    - Integrate with existing YBIS workflows

## Phase 6: Working Implementation Generation
12. **Functional Instance Generation** → Create working implementations
    - Generate functional script data in Veriler/
    - Create working command implementations
    - Generate template instances that actually work
    - Replicate original system functionality in YBIS format

13. **Implementation Validation** → Test working implementations
    - Verify functional equivalence with source system
    - Test all generated scripts and workflows
    - Ensure parameter compatibility and expected outputs

## Phase 7: Platform Export & Integration
14. **Export Integration** → Platform-specific exports
    - Apply export adapters to all new instances
    - Generate Claude commands, VS Code extensions, etc.
    - Ensure exported assets follow target platform standards

15. **Cross-Platform Testing** → Validate exports
    - Test exported implementations on target platforms
    - Verify functionality preservation across exports
    - Ensure platform-specific compliance

## Phase 8: Validation & Registration
10. **Constitutional Compliance** → Verify all Constitutional principles
    - Meta-First: All definitions in Meta/
    - Type-Based: Proper categorization
    - Platform-Agnostic: Core logic separated from platform specifics
    - Validation: Proper must_have contracts

11. **Integration Testing** → Verify system consistency
    - Test new types with existing workflows
    - Validate export processes
    - Check registry integrity
    - Ensure no Constitutional violations

12. **Registry Registration** → Update YBIS registry
    - Register all new types and instances
    - Update meta information
    - Create change log entry
    - Report integration metrics

## Output Report
- **Component Analysis**: Complete inventory of all system components (structural/functional/knowledge/integration/behavioral)
- **Behavioral Patterns**: Discovered workflows, orchestration patterns, team coordination mechanisms
- **YBIS Type Mapping**: How each component maps to YBIS types including behavioral types
- **New YBIS Types**: Types created or extended for complete coverage (including workflow, orchestrator, team types)
- **Generated Assets**: Files created in Meta/ and Veriler/ representing entire ecosystem
- **Relationship Maps**: Inter-component dependencies and execution flows
- **Ecosystem Integration**: How the complete system integrates into YBIS
- **Platform Exports**: Generated platform-specific files
- **Integration Summary**: Success metrics and any issues
- **Next Steps**: Recommended follow-up actions

This command represents the pinnacle of YBIS meta-system capabilities, enabling systematic integration of complete external ecosystems (not just executables) while maintaining Constitutional integrity and type-based architecture.
