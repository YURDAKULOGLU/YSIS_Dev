"""
Protocol definitions for orchestrator_v3 plugin architecture.

This module defines the contracts that all plugins must implement.
Allows easy swapping of implementations without changing core logic.
"""

from typing import Protocol, Any, Dict, List, Optional
from dataclasses import dataclass
from datetime import datetime


# ============================================================================
# DATA STRUCTURES
# ============================================================================

@dataclass
class Plan:
    """Structured plan output from planners"""
    objective: str
    steps: List[str]
    files_to_modify: List[str]
    dependencies: List[str]
    risks: List[str]
    success_criteria: List[str]
    metadata: Dict[str, Any]


@dataclass
class CodeResult:
    """Result from code execution"""
    files_modified: Dict[str, str]  # path -> content
    commands_run: List[str]
    outputs: Dict[str, str]  # command -> output
    success: bool
    error: Optional[str] = None


@dataclass
class VerificationResult:
    """Result from verification/testing"""
    lint_passed: bool
    tests_passed: bool
    coverage: float
    errors: List[str]
    warnings: List[str]
    logs: Dict[str, str]  # log_type -> content


@dataclass
class TaskState:
    """Complete state of a task execution"""
    task_id: str
    task_description: str
    phase: str  # init, plan, execute, verify, commit, done, failed
    plan: Optional[Plan] = None
    code_result: Optional[CodeResult] = None
    verification: Optional[VerificationResult] = None
    retry_count: int = 0
    max_retries: int = 3
    error: Optional[str] = None
    started_at: datetime = None
    completed_at: Optional[datetime] = None
    artifacts_path: str = ".sandbox"


# ============================================================================
# PROTOCOLS (Interfaces for plugins)
# ============================================================================

class PlannerProtocol(Protocol):
    """
    Interface that all planners must implement.

    A planner analyzes a task and generates a structured execution plan.
    Can be implemented by:
    - CrewAI-based planner
    - Simple LLM prompt planner
    - Rule-based planner
    - etc.
    """

    async def plan(self, task: str, context: Dict[str, Any]) -> Plan:
        """
        Generate execution plan for the task.

        Args:
            task: Task description from TASK_BOARD
            context: Additional context (repo state, files, etc)

        Returns:
            Structured Plan object
        """
        ...

    def name(self) -> str:
        """Return planner identifier (for logging)"""
        ...


class ExecutorProtocol(Protocol):
    """
    Interface that all executors must implement.

    An executor takes a plan and produces code/changes.
    Can be implemented by:
    - Local agent executor (Ollama)
    - OpenHands executor
    - Claude API executor
    - etc.
    """

    async def execute(self, plan: Plan, sandbox_path: str) -> CodeResult:
        """
        Execute the plan and generate code.

        Args:
            plan: Structured plan from planner
            sandbox_path: Where to write files (isolated)

        Returns:
            CodeResult with files modified
        """
        ...

    def name(self) -> str:
        """Return executor identifier"""
        ...


class VerifierProtocol(Protocol):
    """
    Interface that all verifiers must implement.

    A verifier checks if the code is valid (lint, test, etc).
    Can be implemented by:
    - Local QA agent
    - Static analysis tools
    - Test runners
    - etc.
    """

    async def verify(self, code_result: CodeResult, sandbox_path: str) -> VerificationResult:
        """
        Verify code quality and correctness.

        Args:
            code_result: Code generated by executor
            sandbox_path: Where code lives

        Returns:
            VerificationResult with pass/fail + logs
        """
        ...

    def name(self) -> str:
        """Return verifier identifier"""
        ...


class ArtifactGeneratorProtocol(Protocol):
    """
    Interface for artifact generation.

    Generates all required documentation artifacts:
    - PLAN.md
    - RUNBOOK.md
    - DECISIONS.json
    - EVIDENCE/logs
    """

    async def generate(self, state: TaskState) -> Dict[str, str]:
        """
        Generate all artifacts for current state.

        Args:
            state: Current task state

        Returns:
            Dict of {file_path: content}
        """
        ...


class TaskBoardProtocol(Protocol):
    """
    Interface for TASK_BOARD integration.

    Handles reading/writing tasks from/to TASK_BOARD.md
    """

    async def get_next_task(self) -> Optional[Dict[str, Any]]:
        """Get next IN PROGRESS task assigned to current agent"""
        ...

    async def update_task_status(self, task_id: str, status: str, metadata: Dict[str, Any]) -> None:
        """Update task status in TASK_BOARD"""
        ...

    async def create_task(self, title: str, description: str, priority: str) -> str:
        """Create new task, return task_id"""
        ...


# ============================================================================
# GATE VALIDATORS (Core logic - not pluggable)
# ============================================================================

class GateValidator:
    """
    Built-in validation logic for gates.

    These are NOT plugins - they're core orchestrator logic.
    Gates ensure quality at each phase transition.
    """

    @staticmethod
    def validate_plan(plan: Plan) -> tuple[bool, Optional[str]]:
        """
        Validate that plan is actionable.

        Returns:
            (is_valid, error_message)
        """
        if not plan.objective:
            return False, "Plan has no objective"

        if len(plan.steps) == 0:
            return False, "Plan has no steps"

        if len(plan.files_to_modify) == 0:
            return False, "Plan specifies no files to modify"

        # Check file count limits (from Constitution)
        file_count = len(plan.files_to_modify)
        if file_count > 50:
            return False, f"Plan modifies too many files ({file_count} > 50). Break into smaller tasks."

        return True, None

    @staticmethod
    def validate_code(code_result: CodeResult) -> tuple[bool, Optional[str]]:
        """
        Validate that code execution succeeded.

        Returns:
            (is_valid, error_message)
        """
        if not code_result.success:
            return False, code_result.error or "Code execution failed"

        if len(code_result.files_modified) == 0:
            return False, "No files were modified"

        # Basic syntax check (can be extended)
        for path, content in code_result.files_modified.items():
            if not content or len(content.strip()) == 0:
                return False, f"File {path} is empty"

        return True, None

    @staticmethod
    def validate_verification(verification: VerificationResult) -> tuple[bool, Optional[str]]:
        """
        Validate that verification passed.

        Returns:
            (is_valid, error_message)
        """
        if not verification.lint_passed:
            return False, f"Lint failed: {', '.join(verification.errors)}"

        if not verification.tests_passed:
            return False, f"Tests failed: {', '.join(verification.errors)}"

        # Coverage check (optional, can be configured)
        if verification.coverage < 0.7:
            return False, f"Coverage too low: {verification.coverage:.1%} < 70%"

        return True, None

    @staticmethod
    def should_retry(state: TaskState) -> bool:
        """Check if we should retry after failure"""
        return state.retry_count < state.max_retries
