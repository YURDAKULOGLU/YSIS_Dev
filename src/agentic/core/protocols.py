"""
Protocol definitions for orchestrator_v3 plugin architecture.

This module defines the contracts that all plugins must implement.
Allows easy swapping of implementations without changing core logic.
"""

from typing import Any, Dict, List, Optional, Protocol, Union
from pydantic import BaseModel, Field
from datetime import datetime

# ============================================================================
# DATA MODELS (Using Pydantic - The Industry Standard)
# ============================================================================

class Plan(BaseModel):
    """Structured plan output from planners"""
    objective: str
    steps: List[str]
    files_to_modify: List[str]
    dependencies: List[str] = Field(default_factory=list)
    risks: List[str] = Field(default_factory=list)
    success_criteria: List[str] = Field(default_factory=list)
    metadata: Dict[str, Any] = Field(default_factory=dict)

class CodeResult(BaseModel):
    """Result from code execution"""
    files_modified: Dict[str, str] = Field(default_factory=dict) # path -> content/status
    commands_run: List[str] = Field(default_factory=list)
    outputs: Dict[str, str] = Field(default_factory=dict) # command -> output
    success: bool
    error: Optional[str] = None

class VerificationResult(BaseModel):
    """Result from verification/testing"""
    lint_passed: bool
    tests_passed: bool
    coverage: float = 0.0
    errors: List[str] = Field(default_factory=list)
    warnings: List[str] = Field(default_factory=list)
    logs: Dict[str, Any] = Field(default_factory=dict)

class TaskState(BaseModel):
    """The central State object for the entire factory. Fields are optional to support partial updates."""
    task_id: str = Field(default="UNKNOWN")
    task_description: str = Field(default="")
    artifacts_path: str = Field(default=".sandbox_worker/default")
    phase: str = "init"
    plan: Optional[Plan] = None
    code_result: Optional[CodeResult] = None
    verification: Optional[VerificationResult] = None
    retry_count: int = 0
    max_retries: int = 3
    error: Optional[str] = None
    started_at: datetime = Field(default_factory=datetime.now)
    completed_at: Optional[datetime] = None
    error_history: List[str] = Field(default_factory=list)
    failed_at: Optional[datetime] = None
    files_modified: List[str] = Field(default_factory=list)
    quality_score: float = 0.0
    final_status: str = "UNKNOWN"

    class Config:
        arbitrary_types_allowed = True


# ============================================================================
# PROTOCOLS (Interfaces for plugins)
# ============================================================================

class PlannerProtocol(Protocol):
    """
    Interface that all planners must implement.

    A planner analyzes a task and generates a structured execution plan.
    Can be implemented by:
    - CrewAI-based planner
    - Simple LLM prompt planner
    - Rule-based planner
    - etc.
    """

    async def plan(self, task: str, context: Dict[str, Any]) -> Plan:
        """
        Generate execution plan for the task.

        Args:
            task: Task description from TASK_BOARD
            context: Additional context (repo state, files, etc)

        Returns:
            Structured Plan object
        """
        ...

    def name(self) -> str:
        """Return planner identifier (for logging)"""
        ...


class ExecutorProtocol(Protocol):
    """
    Interface that all executors must implement.

    An executor takes a plan and produces code/changes.
    Can be implemented by:
    - Local agent executor (Ollama)
    - OpenHands executor
    - Claude API executor
    - etc.
    """

    async def execute(self, plan: Plan, sandbox_path: str, error_history: Optional[List[str]] = None, retry_count: int = 0) -> CodeResult:
        """
        Execute the plan and generate code.

        Args:
            plan: Structured plan from planner
            sandbox_path: Where to write files (isolated)
            error_history: Previous errors from failed attempts (for retry feedback)
            retry_count: Current retry attempt number

        Returns:
            CodeResult with files modified
        """
        ...

    def name(self) -> str:
        """Return executor identifier"""
        ...


class VerifierProtocol(Protocol):
    """
    Interface that all verifiers must implement.

    A verifier checks if the code is valid (lint, test, etc).
    Can be implemented by:
    - Local QA agent
    - Static analysis tools
    - Test runners
    - etc.
    """

    async def verify(self, code_result: CodeResult, sandbox_path: str) -> VerificationResult:
        """
        Verify code quality and correctness.

        Args:
            code_result: Code generated by executor
            sandbox_path: Where code lives

        Returns:
            VerificationResult with pass/fail + logs
        """
        ...

    def name(self) -> str:
        """Return verifier identifier"""
        ...


class ArtifactGeneratorProtocol(Protocol):
    """
    Interface for artifact generation.

    Generates all required documentation artifacts:
    - PLAN.md
    - RUNBOOK.md
    - DECISIONS.json
    - EVIDENCE/logs
    """

    async def generate(self, state: TaskState) -> Dict[str, str]:
        """
        Generate all artifacts for current state.

        Args:
            state: Current task state

        Returns:
            Dict of {file_path: content}
        """
        ...


class TaskBoardProtocol(Protocol):
    """
    Interface for TASK_BOARD integration.

    Handles reading/writing tasks from/to TASK_BOARD.md
    """

    async def get_next_task(self) -> Optional[Dict[str, Any]]:
        """Get next IN PROGRESS task assigned to current agent"""
        ...

    async def update_task_status(self, task_id: str, status: str, metadata: Dict[str, Any]) -> None:
        """Update task status in TASK_BOARD"""
        ...

    async def create_task(self, title: str, description: str, priority: str) -> str:
        """Create new task, return task_id"""
        ...


# ============================================================================
# GATE VALIDATORS (Core logic - not pluggable)
# ============================================================================

class GateValidator:
    """
    Built-in validation logic for gates.

    These are NOT plugins - they're core orchestrator logic.
    Gates ensure quality at each phase transition.
    """

    @staticmethod
    def validate_plan(plan: Plan) -> tuple[bool, Optional[str]]:
        """
        Validate that plan is actionable.

        Returns:
            (is_valid, error_message)
        """
        if not plan.objective:
            return False, "Plan has no objective"

        if len(plan.steps) == 0:
            return False, "Plan has no steps"

        if len(plan.files_to_modify) == 0:
            return False, "Plan specifies no files to modify"

        # Check file count limits (from Constitution)
        file_count = len(plan.files_to_modify)
        if file_count > 50:
            return False, f"Plan modifies too many files ({file_count} > 50). Break into smaller tasks."

        return True, None

    @staticmethod
    def validate_code(code_result: CodeResult) -> tuple[bool, Optional[str]]:
        """
        Validate that code execution succeeded.

        Returns:
            (is_valid, error_message)
        """
        if not code_result.success:
            return False, code_result.error or "Code execution failed"

        if len(code_result.files_modified) == 0:
            return False, "No files were modified"

        # Basic syntax check (can be extended)
        for path, content in code_result.files_modified.items():
            if not content or len(content.strip()) == 0:
                return False, f"File {path} is empty"

        return True, None

    @staticmethod
    def validate_verification(verification: VerificationResult) -> tuple[bool, Optional[str]]:
        """
        Validate that verification passed.

        Returns:
            (is_valid, error_message)
        """
        if not verification.lint_passed:
            return False, f"Lint failed: {', '.join(verification.errors)}"

        if not verification.tests_passed:
            return False, f"Tests failed: {', '.join(verification.errors)}"

        # Coverage check (optional, can be configured)
        if verification.coverage < 0.7:
            return False, f"Coverage too low: {verification.coverage:.1%} < 70%"

        return True, None

    @staticmethod
    def should_retry(state: TaskState) -> bool:
        """
        Check if we should retry after failure.
        CRITICAL: Do not retry on security violations.
        """
        # 1. Check for Security Violations (Fast Fail)
        last_error = state.error
        if not last_error and state.error_history:
            last_error = state.error_history[-1]
            
        if last_error and ("VIOLATION" in last_error or "â›”" in last_error):
            print(f"[GATE] ðŸ›‘ SECURITY VIOLATION DETECTED. NO RETRY ALLOWED.")
            return False

        # 2. Check Retry Count
        return state.retry_count < state.max_retries
